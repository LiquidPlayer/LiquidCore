//
//  promise-polyfill.c
//  LiquidCoreiOS
//
//  Created by Eric Lange on 7/21/18.
//  Copyright Â© 2018 LiquidPlayer. All rights reserved.
//

const char *promise_polyfill =
"(function (global, factory) {\n"
"    typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n"
"    typeof define === 'function' && define.amd ? define(factory) :\n"
"    (factory());\n"
"}(this, (function () { 'use strict';\n"
"\n"
"    var promiseFinally = function(callback) {\n"
"        var constructor = this.constructor;\n"
"        return this.then(\n"
"                         function(value) {\n"
"                             return constructor.resolve(callback()).then(function() {\n"
"                                 return value;\n"
"                             });\n"
"                         },\n"
"                         function(reason) {\n"
"                             return constructor.resolve(callback()).then(function() {\n"
"                                 return constructor.reject(reason);\n"
"                             });\n"
"                         }\n"
"                         );\n"
"    };\n"
"\n"
"    // Store setTimeout reference so promise-polyfill will be unaffected by\n"
"    // other code modifying setTimeout (like sinon.useFakeTimers())\n"
"    var setTimeoutFunc = setTimeout;\n"
"\n"
"    function noop() {}\n"
"\n"
"    // Polyfill for Function.prototype.bind\n"
"    function bind(fn, thisArg) {\n"
"        return function() {\n"
"            fn.apply(thisArg, arguments);\n"
"        };\n"
"    }\n"
"\n"
"    function Promise(fn) {\n"
"        if (!(this instanceof Promise))\n"
"            throw new TypeError('Promises must be constructed via new');\n"
"        if (typeof fn !== 'function') throw new TypeError('not a function');\n"
"        this._state = 0;\n"
"        this._handled = false;\n"
"        this._value = undefined;\n"
"        this._deferreds = [];\n"
"\n"
"        doResolve(fn, this);\n"
"    }\n"
"\n"
"    function handle(self, deferred) {\n"
"        while (self._state === 3) {\n"
"            self = self._value;\n"
"        }\n"
"        if (self._state === 0) {\n"
"            self._deferreds.push(deferred);\n"
"            return;\n"
"        }\n"
"        self._handled = true;\n"
"        Promise._immediateFn(function() {\n"
"            var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n"
"            if (cb === null) {\n"
"                (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n"
"                return;\n"
"            }\n"
"            var ret;\n"
"            try {\n"
"                ret = cb(self._value);\n"
"            } catch (e) {\n"
"                reject(deferred.promise, e);\n"
"                return;\n"
"            }\n"
"            resolve(deferred.promise, ret);\n"
"        });\n"
"    }\n"
"\n"
"    function resolve(self, newValue) {\n"
"        try {\n"
"            // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n"
"            if (newValue === self)\n"
"                throw new TypeError('A promise cannot be resolved with itself.');\n"
"            if (\n"
"                newValue &&\n"
"                (typeof newValue === 'object' || typeof newValue === 'function')\n"
"                ) {\n"
"                var then = newValue.then;\n"
"                if (newValue instanceof Promise) {\n"
"                    self._state = 3;\n"
"                    self._value = newValue;\n"
"                    finale(self);\n"
"                    return;\n"
"                } else if (typeof then === 'function') {\n"
"                    doResolve(bind(then, newValue), self);\n"
"                    return;\n"
"                }\n"
"            }\n"
"            self._state = 1;\n"
"            self._value = newValue;\n"
"            finale(self);\n"
"        } catch (e) {\n"
"            reject(self, e);\n"
"        }\n"
"    }\n"
"\n"
"    function reject(self, newValue) {\n"
"        self._state = 2;\n"
"        self._value = newValue;\n"
"        finale(self);\n"
"    }\n"
"\n"
"    function finale(self) {\n"
"        if (self._state === 2 && self._deferreds.length === 0) {\n"
"            Promise._immediateFn(function() {\n"
"                if (!self._handled) {\n"
"                    Promise._unhandledRejectionFn(self._value);\n"
"                }\n"
"            });\n"
"        }\n"
"\n"
"        for (var i = 0, len = self._deferreds.length; i < len; i++) {\n"
"            handle(self, self._deferreds[i]);\n"
"        }\n"
"        self._deferreds = null;\n"
"    }\n"
"\n"
"    function Handler(onFulfilled, onRejected, promise) {\n"
"        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n"
"        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n"
"        this.promise = promise;\n"
"    }\n"
"\n"
"    /**\n"
"     * Take a potentially misbehaving resolver function and make sure\n"
"     * onFulfilled and onRejected are only called once.\n"
"     *\n"
"     * Makes no guarantees about asynchrony.\n"
"     */\n"
"    function doResolve(fn, self) {\n"
"        var done = false;\n"
"        try {\n"
"            fn(\n"
"               function(value) {\n"
"                   if (done) return;\n"
"                   done = true;\n"
"                   resolve(self, value);\n"
"               },\n"
"               function(reason) {\n"
"                   if (done) return;\n"
"                   done = true;\n"
"                   reject(self, reason);\n"
"               }\n"
"               );\n"
"        } catch (ex) {\n"
"            if (done) return;\n"
"            done = true;\n"
"            reject(self, ex);\n"
"        }\n"
"    }\n"
"\n"
"    Promise.prototype['catch'] = function(onRejected) {\n"
"        return this.then(null, onRejected);\n"
"    };\n"
"\n"
"    Promise.prototype.then = function(onFulfilled, onRejected) {\n"
"        var prom = new this.constructor(noop);\n"
"\n"
"        handle(this, new Handler(onFulfilled, onRejected, prom));\n"
"        return prom;\n"
"    };\n"
"\n"
"    Promise.prototype['finally'] = promiseFinally;\n"
"\n"
"    Promise.all = function(arr) {\n"
"        return new Promise(function(resolve, reject) {\n"
"            if (!arr || typeof arr.length === 'undefined')\n"
"                throw new TypeError('Promise.all accepts an array');\n"
"            var args = Array.prototype.slice.call(arr);\n"
"            if (args.length === 0) return resolve([]);\n"
"            var remaining = args.length;\n"
"\n"
"            function res(i, val) {\n"
"                try {\n"
"                    if (val && (typeof val === 'object' || typeof val === 'function')) {\n"
"                        var then = val.then;\n"
"                        if (typeof then === 'function') {\n"
"                            then.call(\n"
"                                      val,\n"
"                                      function(val) {\n"
"                                          res(i, val);\n"
"                                      },\n"
"                                      reject\n"
"                                      );\n"
"                            return;\n"
"                        }\n"
"                    }\n"
"                    args[i] = val;\n"
"                    if (--remaining === 0) {\n"
"                        resolve(args);\n"
"                    }\n"
"                } catch (ex) {\n"
"                    reject(ex);\n"
"                }\n"
"            }\n"
"\n"
"            for (var i = 0; i < args.length; i++) {\n"
"                res(i, args[i]);\n"
"            }\n"
"        });\n"
"    };\n"
"\n"
"    Promise.resolve = function(value) {\n"
"        if (value && typeof value === 'object' && value.constructor === Promise) {\n"
"            return value;\n"
"        }\n"
"\n"
"        return new Promise(function(resolve) {\n"
"            resolve(value);\n"
"        });\n"
"    };\n"
"\n"
"    Promise.reject = function(value) {\n"
"        return new Promise(function(resolve, reject) {\n"
"            reject(value);\n"
"        });\n"
"    };\n"
"\n"
"    Promise.race = function(values) {\n"
"        return new Promise(function(resolve, reject) {\n"
"            for (var i = 0, len = values.length; i < len; i++) {\n"
"                values[i].then(resolve, reject);\n"
"            }\n"
"        });\n"
"    };\n"
"\n"
"    // Use polyfill for setImmediate for performance gains\n"
"    Promise._immediateFn =\n"
"    (typeof setImmediate === 'function' &&\n"
"     function(fn) {\n"
"         setImmediate(fn);\n"
"     }) ||\n"
"    function(fn) {\n"
"        setTimeoutFunc(fn, 0);\n"
"    };\n"
"\n"
"    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n"
"        if (typeof console !== 'undefined' && console) {\n"
"            console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n"
"        }\n"
"    };\n"
"\n"
"    var globalNS = (function() {\n"
"        // the only reliable means to get the global object is\n"
"        // `Function('return this')()`\n"
"        // However, this causes CSP violations in Chrome apps.\n"
"        if (typeof self !== 'undefined') {\n"
"            return self;\n"
"        }\n"
"        if (typeof window !== 'undefined') {\n"
"            return window;\n"
"        }\n"
"        if (typeof global !== 'undefined') {\n"
"            return global;\n"
"        }\n"
"        throw new Error('unable to locate global object');\n"
"    })();\n"
"\n"
"    if (!globalNS.Promise) {\n"
"        globalNS.Promise = Promise;\n"
"    } else if (!globalNS.Promise.prototype['finally']) {\n"
"        globalNS.Promise.prototype['finally'] = promiseFinally;\n"
"    }\n"
"\n"
"})));\n"
"";
